const world_size: vec3<i32> = vec3<i32>(48, 48, 16);

@group(0) @binding(0) var noise_image: texture_storage_2d<rg32float, write>;

fn ihash1D_vec4(q_in: vec4<u32>) -> vec4<u32> {
    var q = q_in;
    q = q * 747796405u + 2891336453u;
    q.x = (q.x << 13u) ^ q.x;
    q.y = (q.y << 13u) ^ q.y;
    q.z = (q.z << 13u) ^ q.z;
    q.w = (q.w << 13u) ^ q.w;
    return q * (q * q * 15731u + 789221u) + 1376312589u;
}

fn betterHash2D_vec4(cell: vec4<f32>) -> vec4<f32> {
    let i_val = vec4<u32>(cell);
    let hash_val = vec4<u32>(ihash1D_vec4(ihash1D_vec4(i_val.xzxz) + i_val.yyww));
    return vec4<f32>(vec4<f32>(hash_val) * (1.0 / f32(0xffffffffu)));
}

fn betterHash2D_vec4_coords(coords0: vec4<f32>, coords1: vec4<f32>) -> vec4<f32> {
    let hash0_val = ihash1D_vec4(ihash1D_vec4(vec4<u32>(vec2<u32>(coords0.xz), vec2<u32>(coords1.xz))) + vec4<u32>(vec2<u32>(coords0.yw), vec2<u32>(coords1.yw)));
    let tmp_x = ~hash0_val.x ^ 230123u;
    let tmp_y = ~hash0_val.y ^ 230123u;
    let tmp_z = ~hash0_val.z ^ 230123u;
    let tmp_w = ~hash0_val.w ^ 230123u;
    let hash1_val = hash0_val * 1933247u + vec4<u32>(tmp_x, tmp_y, tmp_z, tmp_w);
    let hashX_val = vec4<f32>(vec4<f32>(hash0_val) * (1.0 / f32(0xffffffffu)));
    let hashY_val = vec4<f32>(vec4<f32>(hash1_val) * (1.0 / f32(0xffffffffu)));
    return hashX_val;
}

fn perlinNoise_vec2_float(pos: vec2<f32>, scale: vec2<f32>, seed: f32) -> f32 {
    let pos_scaled = pos * scale;
    let i = vec4<f32>(floor(pos_scaled).xyxy) + vec4<f32>(vec2<f32>(0.0, 1.0).xxyy);
    let f = (vec4<f32>(pos_scaled.xyxy) - vec4<f32>(i.xyxy)) - vec4<f32>(vec2<f32>(0.0, 1.0).xxyy);
    let i_modified = fract(i / scale.xyxy) * scale.xyxy + seed;
    
    let gradientX = betterHash2D_vec4(i_modified);
    let gradientY = betterHash2D_vec4(i_modified);
    let gradientX_modified = gradientX - 0.49999;
    let gradientY_modified = gradientY - 0.49999;
    
    let gradients = inverseSqrt(gradientX_modified * gradientX_modified + gradientY_modified * gradientY_modified) * (gradientX_modified * f.xzxz + gradientY_modified * f.yyww);
    let gradients_modified = gradients * 2.3703703703703703703703703703704;
    let lengthSq = f * f;
    let lengthSq_modified = lengthSq.xzxz + lengthSq.yyww;
    let xSq = 1.0 - min(vec4<f32>(1.0), lengthSq_modified);
    let xSq_modified = xSq * xSq * xSq;
    return dot(xSq_modified, gradients_modified);
}

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let fpix = vec2<f32>(global_id.xy) + 0.5;
    let ipix = vec2<i32>(global_id.xy);
    let noise_val_1 = perlinNoise_vec2_float(fpix/(2.0*vec2<f32>(world_size.xy)), vec2<f32>(3.0), 1.0);
    let noise_val_2 = perlinNoise_vec2_float(fpix/(2.0*vec2<f32>(world_size.xy)), vec2<f32>(3.0), 2.0);
    textureStore(noise_image, ipix, vec4<f32>(noise_val_1, noise_val_2, 0.0,0.0));
}