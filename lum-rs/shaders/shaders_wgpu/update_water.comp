struct UboData {
    trans_w2s: mat4x4<f32>,
    campos: vec4<f32>,
    camdir: vec4<f32>,
    horizline_scaled: vec4<f32>,
    vertiline_scaled: vec4<f32>,
    global_light_dir: vec4<f32>,
    lightmap_proj: mat4x4<f32>,
    frame_size: vec2<f32>,
    wind_direction: vec2<f32>,
    timeseed: i32,
    delta_time: f32,
};

@group(0) @binding(0) var<uniform> ubo: UboData;
@group(0) @binding(1) var water_state: texture_storage_2d<rgba32float, write>;

fn calculate_height(local_pos: vec2<f32>, time: f32) -> f32 {
    var height = 0.0;
    let direction = vec2<f32>(1.0, 1.0);
    var ampl = 1.0;
    var freq = 1.0;
    for (var i: i32 = 0; i < 18; i++) {
        ampl *= 0.8;
        var current_direction = direction;
        current_direction.x += 0.1;
        current_direction = normalize(current_direction);
        let T = time;
        height += ampl * sin(T * freq + dot(current_direction, local_pos) * 6.28318530718); // 2 * PI
        freq *= 1.15;
    }
    return height;
}

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let pix = global_id.xy;
    var pos = (vec2<f32>(pix) + vec2<f32>(0.5)) * (48.0 * 2.0);

    var height: vec4<f32>;
    // let ftime = bitcast<f32>(ubo.timeseed);
    let ftime = f32(ubo.timeseed);
    let time = ftime / 30.0;

    height.x = calculate_height(pos / 1.01, time / 1.25);
    height.y = calculate_height(pos / 1.02, time / 1.5);
    height.z = calculate_height(pos / 1.03, time / 2.5);
    height.w = calculate_height(pos / 1.04, time / 3.5);

    textureStore(water_state, pix, vec4<f32>(height));
}
