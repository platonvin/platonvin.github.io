struct UboData {
    trans_w2s: mat4x4<f32>,
    campos: vec4<f32>,
    camdir: vec4<f32>,
    horizline_scaled: vec4<f32>,
    vertiline_scaled: vec4<f32>,
    global_light_dir: vec4<f32>,
    lightmap_proj: mat4x4<f32>,
    frame_size: vec2<f32>,
    wind_direction: vec2<f32>,
    timeseed: i32,
    delta_time: f32,
};

@group(0) @binding(0) var<uniform> ubo: UboData;
@group(0) @binding(1) var grass_state: texture_storage_2d<rg32float, write>;
@group(0) @binding(2) var perlin_noise: texture_2d<f32>;
@group(0) @binding(3) var linear_sampler: sampler;

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let pix = global_id.xy;
    let pos = (vec2<f32>(pix) + vec2<f32>(0.5)) / 16.0;

    var new_direction = vec2<f32>(0.0);

    let wind_direction = vec2<f32>(1.0, 1.0);
    let ftime = bitcast<f32>(ubo.timeseed);
    let uv_shift = wind_direction * ftime / 300.0;
    let noise_uv = pos + uv_shift;

    let inv_texture_size = vec2<f32>(1.0) / vec2<f32>(textureDimensions(perlin_noise, 0));
    let offset_x = vec2<f32>(inv_texture_size.x, 0.0);
    let offset_y = vec2<f32>(0.0, inv_texture_size.y);

    new_direction.x = textureSampleLevel(perlin_noise, linear_sampler, noise_uv, 0.0).x;
    new_direction.y = textureSampleLevel(perlin_noise, linear_sampler, noise_uv, 0.0).x;

    textureStore(grass_state, pix, vec4<f32>(new_direction,0.0,0.0));
}