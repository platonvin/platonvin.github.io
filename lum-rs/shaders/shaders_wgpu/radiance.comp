struct Material {
    color: vec3<f32>,
    emittance: f32,
    roughness: f32,
    transparency: f32,
};

struct UboData {
    transform_world_to_screen: mat4x4<f32>,
    camera_position: vec4<f32>,
    camera_direction: vec4<f32>,
    horizontal_line_scaled: vec4<f32>,
    vertical_line_scaled: vec4<f32>,
    global_light_direction: vec4<f32>,
    lightmap_projection: mat4x4<f32>,
    frame_size: vec2<f32>,
    wind_direction: vec2<f32>,
    time_seed: i32,
    delta_time: f32,
};

struct UpdateRequest {
    data: vec4<i32>,
};

struct RequestBuffer {
    update_requests: array<UpdateRequest>,
};

@group(0) @binding(0) var<uniform> ubo: UboData;
@group(0) @binding(1) var blocks: texture_3d<i32>;
@group(0) @binding(2) var block_palette: texture_3d<i32>;
@group(0) @binding(3) var voxel_palette: texture_2d<f32>;
@group(0) @binding(4) var radiance_cache_read: texture_3d<f32>;
@group(0) @binding(5) var radiance_cache_write: texture_storage_3d<rgba16float, write>;
@group(0) @binding(6) var<storage, read> request_buffer_ssbo: RequestBuffer;
@group(0) @binding(7) var linear_sampler: sampler;

const BLOCK_PALETTE_SIZE_X: i32 = 64;
const REACTIVENESS: f32 = 0.01;
const RAYS_PER_PROBE: u32 = 64u;
const PI: f32 = 3.1415926535897932384626433832795;
const WORLD_SIZE: vec3<f32> = vec3<f32>(48.0, 48.0, 16.0);

var<private> current_global_light_direction: vec3<f32> = (vec3<f32>(0.5, 0.5, -0.9));

const K_CONSTANT: u32 = 1103515245u;
var<private> random_state_vector: vec3<u32>;

var<workgroup> accumulated_light_shared: array<vec3<f32>, RAYS_PER_PROBE>;

fn hash33(input_value: vec3<u32>) -> vec3<f32> {
    var x = input_value;

    // Iteration 1
    var x_prev_iter = x;
    x.x = ((x_prev_iter.x >> 8u) ^ x_prev_iter.y) * K_CONSTANT;
    x.y = ((x_prev_iter.y >> 8u) ^ x_prev_iter.z) * K_CONSTANT;
    x.z = ((x_prev_iter.z >> 8u) ^ x_prev_iter.x) * K_CONSTANT;

    // Iteration 2
    x_prev_iter = x;
    x.x = ((x_prev_iter.x >> 8u) ^ x_prev_iter.y) * K_CONSTANT;
    x.y = ((x_prev_iter.y >> 8u) ^ x_prev_iter.z) * K_CONSTANT;
    x.z = ((x_prev_iter.z >> 8u) ^ x_prev_iter.x) * K_CONSTANT;

    // Iteration 3
    x_prev_iter = x;
    x.x = ((x_prev_iter.x >> 8u) ^ x_prev_iter.y) * K_CONSTANT;
    x.y = ((x_prev_iter.y >> 8u) ^ x_prev_iter.z) * K_CONSTANT;
    x.z = ((x_prev_iter.z >> 8u) ^ x_prev_iter.x) * K_CONSTANT;

    return vec3<f32>(x) * (1.0 / 4294967295.0); // Scale to [0, 1] range
}

fn random_3d_from_state() -> vec3<f32> {
    let result = hash33(random_state_vector);
    random_state_vector.x = random_state_vector.x + 1u;
    return result;
}

fn random_sphere_point(random_vector: vec3<f32>) -> vec3<f32> {
    let angle1 = (random_vector.x + 1.0) * PI;
    let u = random_vector.y;
    let u2 = u * u;
    let sqrt_1_minus_u2 = sqrt(max(0.0, 1.0 - u2));
    let x = sqrt_1_minus_u2 * cos(angle1);
    let y = sqrt_1_minus_u2 * sin(angle1);
    let z = u;
    return vec3<f32>(x, y, z);
}

fn normal_oriented_hemisphere_point(random_vector: vec3<f32>, normal: vec3<f32>) -> vec3<f32> {
    let vector_on_sphere = random_sphere_point(random_vector);
    return vector_on_sphere * sign(dot(vector_on_sphere, normal));
}

fn get_block(block_position: vec3<i32>) -> i32 {
    let world_dimensions_i32 = vec3<i32>(WORLD_SIZE);
    // TODO:
    let clamped_position = clamp(block_position, vec3<i32>(0), world_dimensions_i32 - vec3<i32>(1));
    return textureLoad(blocks, clamped_position, 0).r;
}

fn voxel_in_palette(relative_voxel_position: vec3<i32>, block_id: i32) -> vec3<i32> {
    let block_x = block_id % BLOCK_PALETTE_SIZE_X;
    let block_y = block_id / BLOCK_PALETTE_SIZE_X;
    return relative_voxel_position + vec3<i32>(16 * block_x, 16 * block_y, 0);
}

fn get_voxel(position: vec3<f32>) -> vec2<i32> {
    let integer_position = vec3<i32>(floor(position));
    let integer_block_position = integer_position / 16;
    let relative_voxel_position = integer_position % 16;

    let block_id = get_block(integer_block_position);
    let voxel_position_in_palette = voxel_in_palette(relative_voxel_position, block_id);
    let voxel_unsigned_int = textureLoad(block_palette, voxel_position_in_palette, 0).r;
    return vec2<i32>(i32(voxel_unsigned_int), block_id);
}

fn get_material(voxel_id: i32) -> Material {
    var material: Material;
    material.color.r = textureLoad(voxel_palette, vec2<i32>(0, voxel_id), 0).r;
    material.color.g = textureLoad(voxel_palette, vec2<i32>(1, voxel_id), 0).r;
    material.color.b = textureLoad(voxel_palette, vec2<i32>(2, voxel_id), 0).r;
    material.emittance = textureLoad(voxel_palette, vec2<i32>(4, voxel_id), 0).r;
    material.roughness = textureLoad(voxel_palette, vec2<i32>(5, voxel_id), 0).r;
    material.transparency = 0.0;
    return material;
}

fn sample_radiance(position: vec3<f32>, normal: vec3<f32>) -> vec3<f32> {
    let offset_position = position + normal * 16.0; // Offset by 16.0.
    let block_position_normalized = offset_position / 16.0;
    let uvw = (block_position_normalized + 0.5) / WORLD_SIZE;
    return textureSampleLevel(radiance_cache_read, linear_sampler, uvw, 0.0).rgb;
}

struct DdaInitResult {
    t_max: vec3<f32>,
    t_delta: vec3<f32>,
    block_position: vec3<i32>,
}
fn init_t_values_struct(ray_origin: vec3<f32>, ray_direction: vec3<f32>) -> DdaInitResult {
    var result: DdaInitResult;
    let effective_origin = ray_origin;
    let inverse_direction = 1.0 / ray_direction;

    let floor_effective_origin = floor(effective_origin);
    let block_corner1 = (floor_effective_origin - effective_origin) * inverse_direction;
    let block_corner2 = (floor_effective_origin + 1.0 - effective_origin) * inverse_direction;

    result.t_max.x = max(block_corner1.x, block_corner2.x);
    result.t_max.y = max(block_corner1.y, block_corner2.y);
    result.t_max.z = max(block_corner1.z, block_corner2.z);
    result.t_delta = abs(inverse_direction);
    result.block_position = vec3<i32>(floor_effective_origin);
    return result;
}

fn cast_ray_fast(origin: vec3<f32>, direction: vec3<f32>, fraction_output: ptr<function, f32>, normal_output: ptr<function, vec3<f32>>, material_output: ptr<function, Material>, left_bounds_output: ptr<function, bool>) -> bool {
    var block_hit = false;
    *fraction_output = 0.0;
    *left_bounds_output = false;

    let one_div_direction = 1.0 / direction;
    let precomputed_corner = direction > vec3<f32>(0.0);
    let precomputed_corner_offset = vec3<f32>(precomputed_corner) * 16.0;

    var voxel_info = get_voxel(origin);
    var current_voxel = voxel_info.x;
    var current_block = voxel_info.y;

    let max_distance = 16.0 * 8.0;

    loop {
        if *fraction_output >= max_distance {
            block_hit = false;
            *left_bounds_output = true;
            break;
        }
        *fraction_output += 0.5;
        let position = origin + direction * (*fraction_output);

        voxel_info = get_voxel(position);
        current_voxel = voxel_info.x;
        current_block = voxel_info.y;

        if (current_block == 0) {
            let block_base_coordinate = floor(position / 16.0) * 16.0;
            let far_corner_of_block = block_base_coordinate + precomputed_corner_offset;
            let t_to_far_corner_planes = (far_corner_of_block - position) * one_div_direction;
            var t_exit = min(t_to_far_corner_planes.x, min(t_to_far_corner_planes.y, t_to_far_corner_planes.z));
            t_exit = max(t_exit, 0.01);
            *fraction_output += t_exit;
        }

        if (current_voxel != 0) {
            block_hit = true;
            break;
        }
        if (any(position < vec3<f32>(0.0)) || any(position >= WORLD_SIZE * 16.0)) { // World bounds
            block_hit = false;
            *left_bounds_output = true;
            break;
        }
    }

    if (block_hit) {
        let before_hit_position = origin + direction * (*fraction_output - 1.5); // Backtrack slightly.

        let dda_parameters = init_t_values_struct(before_hit_position, direction);
        var t_max = dda_parameters.t_max;
        let t_delta = dda_parameters.t_delta;
        var voxel_position_dda = dda_parameters.block_position;

        let steps = select(vec3<i32>(-1), vec3<i32>(1), direction > vec3<f32>(0.0));

        var dda_voxel_id = get_voxel(vec3<f32>(voxel_position_dda) + 0.5).x;
        var float_current_step_direction = vec3<f32>(0.0);

        for (var iter = 0; iter < 4 && dda_voxel_id == 0; iter = iter + 1) {
            if (t_max.x <= t_max.y && t_max.x <= t_max.z) {
                float_current_step_direction = vec3<f32>(1.0, 0.0, 0.0);
            } else if (t_max.y <= t_max.z) {
                float_current_step_direction = vec3<f32>(0.0, 1.0, 0.0);
            } else {
                float_current_step_direction = vec3<f32>(0.0, 0.0, 1.0);
            }

            voxel_position_dda += vec3<i32>(float_current_step_direction) * steps;
            t_max += t_delta * float_current_step_direction;
            dda_voxel_id = get_voxel(vec3<f32>(voxel_position_dda) + 0.5).x;
        }

        *normal_output = -vec3<f32>(steps) * float_current_step_direction;
        let dda_fraction_offset = dot(t_max - t_delta * abs(float_current_step_direction), abs(float_current_step_direction));
        *fraction_output = (*fraction_output - 1.5) + dda_fraction_offset;
        *material_output = get_material(dda_voxel_id);

        return (dda_voxel_id != 0);
    }
    return block_hit;
}

fn spherical_fibonacci(i: f32, n: f32) -> vec3<f32> {
    let phi_constant = sqrt(5.0) * 0.5 + 0.5;
    let phi_angle = 2.0 * PI * fract(i * (phi_constant - 1.0));
    let cos_theta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    let sin_theta = sqrt(max(0.0, 1.0 - cos_theta * cos_theta));
    return vec3<f32>(cos(phi_angle) * sin_theta, sin(phi_angle) * sin_theta, cos_theta);
}

fn probe_id_to_ray_direction(probe_id: i32) -> vec3<f32> {
    return spherical_fibonacci(f32(probe_id), f32(RAYS_PER_PROBE));
}

fn trace_ray(ray_position_input: vec3<f32>, ray_direction_input: vec3<f32>) -> vec3<f32> {
    var fraction: f32;
    var normal: vec3<f32>;
    var material: Material;
    var left_bounds: bool;

    let hit = cast_ray_fast(ray_position_input, ray_direction_input, &fraction, &normal, &material, &left_bounds);
    var light = vec3<f32>(0.0);
    let reflection_albedo = vec3<f32>(1.0);

    if (hit) {
        let hit_position = ray_position_input + fraction * ray_direction_input;
        let propagated_light = sample_radiance(hit_position, normal);
        light += reflection_albedo * propagated_light * material.color + material.color * material.emittance;
    } else {
        let global_light_participance = -dot(ray_direction_input, current_global_light_direction);
        if (global_light_participance > 0.95) {
            light += reflection_albedo * global_light_participance * (vec3<f32>(0.9, 0.9, 0.6) * 3.0);
        }
        light += reflection_albedo * (vec3<f32>(0.53, 0.81, 0.92) * 0.1); // Sky blue ambient
    }
    return light;
}

fn store_probe(probe_position_store: vec3<i32>, accumulated_light_store: vec3<f32>) {
    let read_uvw = (vec3<f32>(probe_position_store) + 0.5) / WORLD_SIZE;
    let old_light = textureSampleLevel(radiance_cache_read, linear_sampler, read_uvw, 0.0).rgb;

    let old_light_clamped = clamp(old_light, vec3<f32>(0.0), vec3<f32>(1.0));
    let new_light = mix(old_light_clamped, accumulated_light_store, REACTIVENESS);
    textureStore(radiance_cache_write, probe_position_store, vec4<f32>(new_light, 1.0));
}

@compute @workgroup_size(RAYS_PER_PROBE, 1, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>, @builtin(local_invocation_id) local_id: vec3<u32>) {
    current_global_light_direction = normalize(current_global_light_direction);

    let probe_index_in_workgroup = local_id.x;
    let request_index = global_id.x / RAYS_PER_PROBE;

    let request_data = request_buffer_ssbo.update_requests[request_index].data;
    let probe_position_world = request_data.xyz;

    random_state_vector = vec3<u32>(global_id.xy + u32(ubo.time_seed), u32(ubo.time_seed));

    let block_corner_world = vec3<f32>(probe_position_world) * 16.0;
    let block_center_world = block_corner_world + 8.0;

    var ray_origin = block_center_world;
    var ray_direction = probe_id_to_ray_direction(i32(probe_index_in_workgroup));

    ray_direction = normalize(ray_direction + 0.1 * ((random_3d_from_state() - 0.5) * 2.0));
    ray_origin += ray_direction * 6.0;
    ray_origin += (random_3d_from_state() - 0.5) * 2.0; // Jitter origin as a way to sample spatially

    ray_direction = select(-ray_direction, ray_direction,(probe_index_in_workgroup % 2u) == 0u);

    let individual_ray_light = trace_ray(ray_origin, ray_direction);

    accumulated_light_shared[local_id.x] = individual_ray_light;
    workgroupBarrier();

    // Parallel sum reduction
    // I just hope it converts to something like subgroupAdd
    var num_active_threads = RAYS_PER_PROBE;
    for (var offset = num_active_threads / 2u; offset > 0u; offset = offset / 2u) {
        if (local_id.x < offset) {
            accumulated_light_shared[local_id.x] += accumulated_light_shared[local_id.x + offset];
        }
        workgroupBarrier();
    }

    if (local_id.x == 0u) {
        let total_light_sum = accumulated_light_shared[0];
        let final_averaged_light = total_light_sum / f32(RAYS_PER_PROBE);
        store_probe(probe_position_world, final_averaged_light);
    }
}
