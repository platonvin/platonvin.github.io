const world_size: vec3<i32> = vec3<i32>(48, 48, 16);

@group(0) @binding(0) var noise_image: texture_storage_3d<rgba32float, write>;

const UI0: u32 = 1597334673u;
const UI1: u32 = 3812015801u;
const UI2: vec2<u32> = vec2<u32>(UI0, UI1);
const UI3: vec3<u32> = vec3<u32>(UI0, UI1, 2798796415u);
const UIF: f32 = 1.0 / f32(0xffffffffu);

fn hash33(p_in: vec3<f32>) -> vec3<f32> {
    let q = vec3<u32>(floor(p_in)) * UI3;
    let q_modified = (q.x ^ q.y ^ q.z) * UI3;
    return -1.0 + 2.0 * vec3<f32>(q_modified) * UIF;
}

fn remap(x: f32, a: f32, b: f32, c: f32, d: f32) -> f32 {
    return (((x - a) / (b - a)) * (d - c)) + c;
}

fn gradientNoise(x: vec3<f32>, freq: f32) -> f32 {
    // grid
    let p = floor(x);
    let w = fract(x);

    // quintic interpolant
    let u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);

    // gradients
    let ga = hash33(fract(p / freq) * freq + vec3<f32>(0.0, 0.0, 0.0));
    let gb = hash33(fract((p + vec3<f32>(1.0, 0.0, 0.0)) / freq) * freq);
    let gc = hash33(fract((p + vec3<f32>(0.0, 1.0, 0.0)) / freq) * freq);
    let gd = hash33(fract((p + vec3<f32>(1.0, 1.0, 0.0)) / freq) * freq);
    let ge = hash33(fract((p + vec3<f32>(0.0, 0.0, 1.0)) / freq) * freq);
    let gf = hash33(fract((p + vec3<f32>(1.0, 0.0, 1.0)) / freq) * freq);
    let gg = hash33(fract((p + vec3<f32>(0.0, 1.0, 1.0)) / freq) * freq);
    let gh = hash33(fract((p + vec3<f32>(1.0, 1.0, 1.0)) / freq) * freq);

    // projections
    let va = dot(ga, w - vec3<f32>(0.0, 0.0, 0.0));
    let vb = dot(gb, w - vec3<f32>(1.0, 0.0, 0.0));
    let vc = dot(gc, w - vec3<f32>(0.0, 1.0, 0.0));
    let vd = dot(gd, w - vec3<f32>(1.0, 1.0, 0.0));
    let ve = dot(ge, w - vec3<f32>(0.0, 0.0, 1.0));
    let vf = dot(gf, w - vec3<f32>(1.0, 0.0, 1.0));
    let vg = dot(gg, w - vec3<f32>(0.0, 1.0, 1.0));
    let vh = dot(gh, w - vec3<f32>(1.0, 1.0, 1.0));

    // interpolation
    return va +
           u.x * (vb - va) +
           u.y * (vc - va) +
           u.z * (ve - va) +
           u.x * u.y * (va - vb - vc + vd) +
           u.y * u.z * (va - vc - ve + vg) +
           u.z * u.x * (va - vb - ve + vf) +
           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);
}

fn worleyNoise(uv_in: vec3<f32>, freq: f32) -> f32 {
    let id = floor(uv_in);
    let p = fract(uv_in);

    var minDist = 10000.0;
    for (var x: f32 = -1.0; x <= 1.0; x += 1.0) {
        for (var y: f32 = -1.0; y <= 1.0; y += 1.0) {
            for (var z: f32 = -1.0; z <= 1.0; z += 1.0) {
                let offset = vec3<f32>(x, y, z);
                let h = hash33(fract((id + offset) / vec3<f32>(freq, freq, freq)) * vec3<f32>(freq, freq, freq)) * 0.5 + 0.5;
                let h_offset = h + offset;
                let d = p - h_offset;
                minDist = min(minDist, dot(d, d));
            }
        }
    }

    // inverted worley noise
    return 1.0 - minDist;
}

fn perlinfbm(p: vec3<f32>, freq: f32, octaves: i32) -> f32 {
    let G = exp2(-0.85);
    var amp = 1.0;
    var noise = 0.0;
    var current_freq = freq;
    for (var i: i32 = 0; i < octaves; i += 1) {
        noise += amp * gradientNoise(p * current_freq, current_freq);
        current_freq *= 2.0;
        amp *= G;
    }

    return noise;
}

fn worleyFbm(p: vec3<f32>, freq: f32) -> f32 {
    return worleyNoise(p * freq, freq) * 0.625 +
           worleyNoise(p * freq * 2.0, freq * 2.0) * 0.25 +
           worleyNoise(p * freq * 4.0, freq * 4.0) * 0.125;
}

@compute @workgroup_size(4, 4, 4)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let fpix = vec3<f32>(global_id) + 0.5;
    let ipix = vec3<i32>(fpix);
    let freq = 3.0;

    let noise_val_x = worleyFbm(fpix / 32.0, freq);
    let noise_val_y = worleyFbm(fpix / 32.0, freq * 2.0);
    let noise_val_z = worleyFbm(fpix / 32.0, freq * 4.0);
    let noise_val_w = worleyFbm(fpix / 32.0, freq * 8.0);

    textureStore(noise_image, ipix, vec4<f32>(noise_val_x, noise_val_y, noise_val_z, noise_val_w));
}