use std::{
    collections::HashSet,
    env, fs,
    io::Write,
    path::{Path, PathBuf},
    process::Command,
    time::SystemTime,
};

fn main() -> std::io::Result<()> {
    println!("cargo:rerun-if-changed=shaders/");
    println!("cargo:rerun-if-changed=shaders_wgpu/");

    check_for_command(
        "glslc",
        "--version",
        "glslc not found. SPIR-V shaders will not be compiled.",
    );

    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let compiled_dir = out_dir.join("compiled_shaders");
    fs::create_dir_all(&compiled_dir)?;

    // Compile SPIR-V and collect names (e.g. "grass.vert")
    let spirv = compile_spirv_shaders(&compiled_dir)?;
    // Just scan WGSL dir and collect names (no copy)
    let wgsl = collect_wgsl_shaders()?;

    // Warn about any SPIR-V shader missing a WGSL twin
    for name in &spirv {
        if !wgsl.contains(name) {
            println!(
                "cargo:warning=Shader '{}' built for Vulkan but no WGSL source found",
                name
            );
        }
    }

    // Generate unified enum
    generate_shader_enum(&out_dir.join("shader_enums.rs"), &spirv, &wgsl)?;

    // At runtime we'll load SPIR-V from here:
    println!(
        "cargo:rustc-env=COMPILED_SHADERS_PATH={}/",
        compiled_dir.display()
    );

    Ok(())
}

fn compile_spirv_shaders(dest: &Path) -> std::io::Result<Vec<String>> {
    let mut names = Vec::new();
    let src = Path::new("shaders");
    if !src.exists() {
        return Ok(names);
    }

    for entry in fs::read_dir(src)? {
        let path = entry?.path();
        // match .glsl, .vert, .frag, etc.
        if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
            match ext {
                "glsl" | "vert" | "frag" | "comp" | "tesc" | "tese" | "geom" => {
                    let file_name = path.file_name().unwrap().to_str().unwrap();
                    // strip trailing ".glsl" if present, else keep full name to preserve stage
                    let name = if file_name.ends_with(".glsl") {
                        file_name.trim_end_matches(".glsl")
                    } else {
                        file_name
                    }
                    .to_string();

                    let out_path = dest.join(format!("{}.spv", name));
                    if needs_recompile(&path, &out_path) {
                        println!("cargo:warning=Compiling SPIR‑V: {}", path.display());
                        let status = Command::new("glslc")
                            .arg(&path)
                            .arg("-o")
                            .arg(&out_path)
                            .arg("--target-env=vulkan1.1")
                            .arg("-g")
                            .status()
                            .expect("Failed to launch glslc");
                        if !status.success() {
                            panic!("glslc failed on {}", path.display());
                        }
                    }
                    names.push(name);
                }
                _ => {}
            }
        }
    }
    Ok(names)
}

fn collect_wgsl_shaders() -> std::io::Result<Vec<String>> {
    let mut names = Vec::new();
    let src = Path::new("shaders_wgpu");
    if !src.exists() {
        return Ok(names);
    }

    for entry in fs::read_dir(src)? {
        let path = entry?.path();
        if path.is_file() {
            let file_name = path.file_name().unwrap().to_str().unwrap();
            // assume `.wgsl` suffix
            let name = file_name.trim_end_matches(".wgsl").to_string();
            names.push(name);
        }
    }
    Ok(names)
}

fn generate_shader_enum(out_file: &Path, spirv: &[String], wgsl: &[String]) -> std::io::Result<()> {
    let mut file = fs::File::create(out_file)?;

    // Union & sort
    let mut all: HashSet<_> = spirv.iter().chain(wgsl.iter()).collect();
    let mut sorted: Vec<_> = all.drain().collect();
    sorted.sort();

    writeln!(
        file,
        "// @generated by build.rs — do not edit\n\
         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n\
         pub enum Shader {{"
    )?;
    for name in &sorted {
        writeln!(file, "    {},", to_pascal(name))?;
    }
    writeln!(file, "}}\n")?;

    // SPIR-V loader
    writeln!(
        file,
        "impl Shader {{\n    #[cfg(feature = \"vk_backend\")]\n\
         pub fn get_spirv(self) -> &'static [u8] {{\n        match self {{"
    )?;
    for name in &sorted {
        if spirv.contains(name) {
            writeln!(
                file,
                "            Shader::{} => include_bytes!(concat!(env!(\"COMPILED_SHADERS_PATH\"), \"{}.spv\")),",
                to_pascal(name),
                name
            )?;
        } else {
            writeln!(
                file,
                "            Shader::{} => panic!(\"'{}' not built for Vulkan backend\"),",
                to_pascal(name),
                name
            )?;
        }
    }
    writeln!(file, "        }}\n    }}")?;

    // WGSL loader (direct from source dir)
    writeln!(
        file,
        "\n    #[cfg(feature = \"wgpu_backend\")]\n\
         pub fn get_wgsl(self) -> &'static str {{\n        match self {{"
    )?;
    for name in &sorted {
        if wgsl.contains(name) {
            writeln!(
                file,
                "            Shader::{} => include_str!(concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/shaders_wgpu/\", \"{}\")),",
                to_pascal(name),
                name
            )?;
        } else {
            writeln!(
                file,
                "            Shader::{} => panic!(\"'{}' not available for WGSL backend\"),",
                to_pascal(name),
                name
            )?;
        }
    }
    writeln!(file, "        }}\n    }}\n}}")?;

    Ok(())
}

fn needs_recompile(src: &Path, out: &Path) -> bool {
    if !out.exists() {
        return true;
    }
    let src_m = fs::metadata(src).and_then(|m| m.modified()).unwrap_or(SystemTime::UNIX_EPOCH);
    let out_m = fs::metadata(out).and_then(|m| m.modified()).unwrap_or(SystemTime::UNIX_EPOCH);
    src_m > out_m
}

fn to_pascal(s: &str) -> String {
    s.split(|c: char| c == '.' || c == '_')
        .filter(|w| !w.is_empty())
        .map(|w| {
            let mut ch = w.chars();
            ch.next()
                .map(|c| c.to_ascii_uppercase())
                .into_iter()
                .chain(ch)
                .collect::<String>()
        })
        .collect()
}

fn check_for_command(cmd: &str, version_arg: &str, err: &str) {
    if Command::new(cmd).arg(version_arg).output().is_err() {
        panic!("{}", err);
    }
}
