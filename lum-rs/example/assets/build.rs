use block_mesh::{
    greedy_quads,
    ndshape::{RuntimeShape, Shape},
    GreedyQuadsBuffer, Voxel, VoxelVisibility, RIGHT_HANDED_Y_UP_CONFIG,
};
use lum::{
    load_interface::{Metadata, SimpleFaceIndices, SimpleVertex},
    types::{ivec3, Material},
};
use std::{
    env, fs,
    io::{self, Write},
    mem::size_of,
    path::{Path, PathBuf},
    time::SystemTime,
};
use vek::Vec3;
use voxc::load::MatlType;

fn main() -> io::Result<()> {
    println!("cargo:rerun-if-changed=assets/");

    // setup where to get assets and where to put them
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let assets_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap()).join("assets");
    let processed_assets_dir = out_dir.join("assets");
    fs::create_dir_all(&processed_assets_dir)?;

    // palette is single file
    process_palette(&assets_dir, &out_dir)?;
    let block_names = process_asset_directory("blocks", &assets_dir, &out_dir, true)?;
    let model_names = process_asset_directory("models", &assets_dir, &out_dir, false)?;

    // generate enum variants corresponding to file names (enum > string)
    generate_enums_file(&out_dir.join("asset_enums.rs"), &block_names, &model_names)?;

    println!(
        "cargo:rustc-env=PROCESSED_ASSETS_PATH={}/",
        processed_assets_dir.display()
    );

    Ok(())
}

// Processes all `.vox` files in a given subdirectory (e.g., "blocks", "models").
fn process_asset_directory(
    sub_dir: &str,
    assets_dir: &Path,
    out_dir: &Path,
    is_block: bool, // this could be separate function
) -> io::Result<Vec<String>> {
    let mut asset_ids = Vec::new();
    let source_path = assets_dir.join(sub_dir);
    if !source_path.exists() {
        return Ok(asset_ids);
    }

    let glob_pattern = source_path.join("*.vox");
    for entry in glob::glob(&glob_pattern.to_string_lossy()).unwrap() {
        match entry {
            Ok(path) => asset_ids.push(process_asset(&path, out_dir, is_block)?),
            Err(e) => eprintln!("cargo:warning=Failed to process glob entry: {}", e),
        }
    }
    Ok(asset_ids)
}

// Processes a single asset file.
fn process_asset(path: &Path, out_dir: &Path, is_block: bool) -> io::Result<String> {
    let stem = path.file_stem().unwrap().to_str().unwrap();
    let asset_out_dir = out_dir.join("assets");

    let meta_path = asset_out_dir.join(format!("{}.meta.bin", stem));
    let voxels_path = asset_out_dir.join(format!("{}.voxels.bin", stem));
    let vertices_path = asset_out_dir.join(format!("{}.vertices.bin", stem));
    let indices_path = asset_out_dir.join(format!("{}.indices.bin", stem));

    let output_paths = [&meta_path, &voxels_path, &vertices_path, &indices_path];
    if !needs_recompile(path, &output_paths) {
        return Ok(stem.to_string());
    }

    println!("cargo:warning=Processing asset: {}", path.display());

    let (metadata, voxels, vertices, indices) = process_vox_file(path, is_block);

    fs::write(&meta_path, metadata.as_u8_slice())?;
    fs::write(&voxels_path, &voxels)?;
    fs::write(&vertices_path, as_byte_slice(&vertices))?;
    fs::write(&indices_path, as_byte_slice(&indices))?;

    Ok(stem.to_string())
}

// Generates the `asset_enums.rs` file with `BlockAsset` and `ModelAsset` enums
// This is a stronger typed way of accessing assets (then by strings)
#[rustfmt::skip] 
fn generate_enums_file(path: &Path, blocks: &[String], models: &[String]) -> io::Result<()> {
    let mut file = fs::File::create(path)?;

    writeln!(
        file,
"// THIS FILE IS @generated by build.rs - DO NOT EDIT BY HAND (please)

use lum::{{
    include_bytes_aligned,
    load_interface::{{cast_meta, cast_slice, BlockData, ModelData}},
    types::Material
}};
        ")?;

    generate_asset_type(
        &mut file,
        "BlockAsset",
        "Type-safe ID for 16x16x16 block assets.",
        blocks,
        "BlockData",
        true,
    )?;

    generate_asset_type(
        &mut file,
        "ModelAsset",
        "Type-safe ID for variable-sized model assets.",
        models,
        "ModelData",
        false,
    )?;

    Ok(())
}

// Generate an asset enum and its associated `load` implementation.
fn generate_asset_type(
    file: &mut fs::File,
    enum_name: &str,
    doc: &str,
    ids: &[String],
    data_struct: &str,
    is_block: bool,
) -> io::Result<()> {
    // honestly just look into generated file to find problems
    writeln!(file, "\n/// {}", doc)?;
    writeln!(file, "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]")?;
    writeln!(file, "pub enum {} {{", enum_name)?;
    for id in ids {
        writeln!(file, "    {},", to_pascal_case(id))?;
    }
    writeln!(file, "}}\n")?;

    writeln!(file, "impl {} {{", enum_name)?;
    writeln!(
        file,
        "    /// Load this asset's data from the embedded bytes."
    )?;
    writeln!(file, "    pub fn load(self) -> {}<'static> {{", data_struct)?;
    writeln!(file, "        match self {{")?;
    for id in ids {
        writeln!(
            file,
            "            {}::{} => {{",
            enum_name,
            to_pascal_case(id)
        )?;
        writeln!(file, "                let meta_bytes = include_bytes_aligned!(16, concat!(env!(\"PROCESSED_ASSETS_PATH\"), \"{}.meta.bin\"));", id)?;
        writeln!(file, "                let voxel_bytes = include_bytes_aligned!(16, concat!(env!(\"PROCESSED_ASSETS_PATH\"), \"{}.voxels.bin\"));", id)?;
        writeln!(file, "                let vertex_bytes = include_bytes_aligned!(16, concat!(env!(\"PROCESSED_ASSETS_PATH\"), \"{}.vertices.bin\"));", id)?;
        writeln!(file, "                let index_bytes = include_bytes_aligned!(16, concat!(env!(\"PROCESSED_ASSETS_PATH\"), \"{}.indices.bin\"));", id)?;
        writeln!(file, "                let meta = cast_meta(meta_bytes);")?;

        if is_block {
            writeln!(
                file,
                r#"
                {} {{
                    iv: meta.face_indices,
                    voxels: unsafe {{ &*(voxel_bytes.as_ptr() as *const _) }},
                    vertices: cast_slice(vertex_bytes),
                    indices: cast_slice(index_bytes),
                }}
            "#,
                data_struct
            )?;
        } else {
            writeln!(
                file,
                r#"
                {} {{
                    size: vek::Vec3::<i32>::new(meta.size[0] as i32, meta.size[1] as i32, meta.size[2] as i32),
                    iv: meta.face_indices,
                    voxels: voxel_bytes,
                    vertices: cast_slice(vertex_bytes),
                    indices: cast_slice(index_bytes),
                }}
            "#,
                data_struct
            )?;
        }
        writeln!(file, "            }}")?;
    }
    writeln!(file, "        }}")?;
    writeln!(file, "    }}")?;
    writeln!(file, "}}\n")?;
    Ok(())
}

#[derive(Clone, Copy, Default, Eq, PartialEq)]
struct InternalVoxel(lum::types::Voxel);

impl Voxel for InternalVoxel {
    fn get_visibility(&self) -> VoxelVisibility {
        if self.0 == 0 {
            VoxelVisibility::Empty
        } else {
            VoxelVisibility::Opaque
        }
    }
}
impl block_mesh::MergeVoxel for InternalVoxel {
    type MergeValue = u8;
    fn merge_value(&self) -> Self::MergeValue {
        self.0
    }
}

/// Read, mesh and repack voxel data from file.
fn process_vox_file(
    path: &Path,
    is_block: bool,
) -> (Metadata, Vec<u8>, Vec<SimpleVertex>, Vec<u16>) {
    let scene = voxc::load::read_scene_from_file(path.to_str().unwrap()).unwrap();
    assert!(
        scene.models.len() == 1,
        "VOX file must contain exactly one model"
    );

    let model = &scene.models[0];
    let size = Vec3::new(model.size_x, model.size_y, model.size_z);

    if is_block {
        assert!(
            size == Vec3::new(16, 16, 16),
            "Asset '{}' in 'blocks' must be 16x16x16, but was {}x{}x{}",
            path.display(),
            size.x,
            size.y,
            size.z
        );
    }

    let (vertices, indices, face_indices) = if model.voxel_data.is_empty() {
        (Vec::new(), Vec::new(), SimpleFaceIndices::default())
    } else {
        mesh_from_voxels(size, &model.voxel_data)
    };

    let metadata = Metadata {
        size: ivec3::new(size.x as i32, size.y as i32, size.z as i32),
        face_indices,
    };
    (metadata, model.voxel_data.clone(), vertices, indices)
}

/// Make countour triangles from voxels. Why countour? -> see Lum internals.
fn mesh_from_voxels(
    size: Vec3<u32>,
    voxel_data: &[u8],
) -> (Vec<SimpleVertex>, Vec<u16>, SimpleFaceIndices) {
    let padded_dims = size + 2;
    // we need to add "empty" padding because mesher needs it
    let mut padded_voxels =
        vec![InternalVoxel(0); (padded_dims.x * padded_dims.y * padded_dims.z) as usize];
    let padded_shape = RuntimeShape::<u32, 3>::new(padded_dims.into_array());

    for x in 0..size.x {
        for y in 0..size.y {
            for z in 0..size.z {
                let model_idx = (x + y * size.x + z * size.x * size.y) as usize;
                let padded_idx = padded_shape.linearize([x + 1, y + 1, z + 1]);
                padded_voxels[padded_idx as usize] = InternalVoxel(voxel_data[model_idx]);
            }
        }
    }

    let mut buffer = GreedyQuadsBuffer::new(padded_voxels.len());
    let faces = RIGHT_HANDED_Y_UP_CONFIG.faces;
    greedy_quads(
        &padded_voxels,
        &padded_shape,
        [0; 3],
        [size.x + 1, size.y + 1, size.z + 1],
        &faces,
        &mut buffer,
    );

    let num_quads = buffer.quads.num_quads();
    let mut indices_u32 = Vec::with_capacity(num_quads * 6);
    let mut positions = Vec::with_capacity(num_quads * 4);
    let mut normals = Vec::with_capacity(num_quads * 4);

    for (group, face) in buffer.quads.groups.into_iter().zip(faces.into_iter()) {
        for quad in group.into_iter() {
            indices_u32.extend_from_slice(&face.quad_mesh_indices(positions.len() as u32));
            positions.extend_from_slice(&face.quad_mesh_positions(&quad, 1.0));
            normals.extend_from_slice(&face.quad_mesh_normals());
        }
    }

    let vertices = positions
        .iter()
        .map(|p| SimpleVertex {
            pos: [(p[0] - 1.0) as u8, (p[1] - 1.0) as u8, (p[2] - 1.0) as u8].into(),
        })
        .collect();

    let (all_indices_sorted, face_indices) = sort_indices_by_normal(&indices_u32, &normals);
    (vertices, all_indices_sorted, face_indices)
}

fn sort_indices_by_normal(indices: &[u32], normals: &[[f32; 3]]) -> (Vec<u16>, SimpleFaceIndices) {
    let mut buckets: [Vec<u16>; 6] = Default::default();
    for tri_indices in indices.chunks(3) {
        let n = normals[tri_indices[0] as usize];
        let bucket_index = if n[0] > 0.5 {
            0
        } else if n[0] < -0.5 {
            1
        } else if n[1] > 0.5 {
            2
        } else if n[1] < -0.5 {
            3
        } else if n[2] > 0.5 {
            4
        } else {
            5
        };
        buckets[bucket_index].extend(tri_indices.iter().map(|&i| i as u16));
    }

    let mut all_indices = Vec::new();
    let mut face_indices = SimpleFaceIndices::default();
    let faces = [
        &mut face_indices.Pzz,
        &mut face_indices.Nzz,
        &mut face_indices.zPz,
        &mut face_indices.zNz,
        &mut face_indices.zzP,
        &mut face_indices.zzN,
    ];

    for (i, bucket) in buckets.iter().enumerate() {
        faces[i].offset = all_indices.len() as u32;
        faces[i].icount = bucket.len() as u32;
        all_indices.extend_from_slice(bucket);
    }
    (all_indices, face_indices)
}

/// Extract palette from scene with palette.
/// (likely "test" scene with all voxels placed to see how they interact, but can be empty - we dont care)
fn process_palette(assets_dir: &Path, out_dir: &Path) -> io::Result<Option<PathBuf>> {
    let source_path = assets_dir.join("palette.vox");
    if !source_path.exists() {
        eprintln!("cargo:warning=No assets/palette.vox found, skipping palette generation.");
        return Ok(None);
    }

    let out_path = out_dir.join("palette.bin");

    if !needs_recompile(&source_path, &[&out_path]) {
        return Ok(Some(out_path));
    }

    println!(
        "cargo:warning=Processing palette: {}",
        source_path.display()
    );

    let scene = voxc::load::read_scene_from_file(source_path.to_str().unwrap()).unwrap();

    let mut materials = [Material::default(); 256];

    for (i, color) in scene.palette.color.iter().enumerate() {
        materials[i].albedo = Vec3::new(color.x as f32, color.y as f32, color.z as f32) / 255.0;
        materials[i].transparency = color.w as f32 / 255.0;
    }

    for i in 0..scene.materials.matl.len() {
        match scene.materials.matl[i].type_ {
            MatlType::Diffuse => {
                materials[i].emmitness = 0.0;
                materials[i].roughness = 1.0;
            }
            MatlType::Emit => {
                materials[i].emmitness =
                    scene.materials.matl[i].emit * (2.0 + scene.materials.matl[i].flux * 4.0);
                materials[i].roughness = 0.5;
            }
            MatlType::Metal => {
                materials[i].emmitness = 0.0;
                materials[i].roughness =
                    scene.materials.matl[i].rough + (1.0 - scene.materials.matl[i].metal) / 2.0;
            }
            other_type => {
                eprintln!("Unknown material type: {:#?}", other_type)
            }
        }
    }

    fs::write(&out_path, as_byte_slice(&materials))?;
    Ok(Some(out_path))
}

// i feel like im missing something
fn needs_recompile(source: &Path, outputs: &[&PathBuf]) -> bool {
    let get_mod_time = |path: &Path| {
        fs::metadata(path).and_then(|m| m.modified()).unwrap_or(SystemTime::UNIX_EPOCH)
    };
    let source_mod = get_mod_time(source);
    outputs.iter().any(|p| !p.exists() || get_mod_time(p) < source_mod)
}

fn as_byte_slice<T: Sized>(data: &[T]) -> &[u8] {
    let len = data.len() * size_of::<T>();
    let ptr = data.as_ptr() as *const u8;
    unsafe { std::slice::from_raw_parts(ptr, len) }
}

fn to_pascal_case(s: &str) -> String {
    let mut pascal = String::new();
    let mut capitalize = true;
    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize = true;
        } else if capitalize {
            pascal.push(c.to_ascii_uppercase());
            capitalize = false;
        } else {
            pascal.push(c);
        }
    }
    pascal
}
