---
title: My Experience with Rust
lang: en
css: ../styles.css
backlink: ../index.html
googlefonts: true
headline: my experience with `Rust`
intro_footer: |
    <p><em>it might look like too much highlighting for you, but it really increases accessability for some people</em></p>
    <p><em>information is subjective. Treat it as a story about experience</em></p>
---

# My Experience with Rust (This will become the main article title if `headline` isn't used)

## why?

One of my friends was actively pitching `Rust` as new shiny thing i should try. I did not really want to learn a new language just for fun, but after a week of attempts on integrating `C++23` modules into my renderer (I just wanted faster compile times without headers), which failed completely - bugs literally everywhere, ICEs, documentation so bad that reading source was more useful, - I realized how much time I spend on `CMake` (and earlier `Make` - I love slashes btw), dependency management, resolving compiler differences and other non-programming stuff, and thought that maybe `Rust` could solve that

So, the obvious thing to do was to port my entire C++ Vulkan renderer (*almost*) line by line without trying to run it once

<small>If you are experienced Rust dev, i would really appreciate code review of my <b><a href="https:/github.com/platonvin/lum-rs">renderer </a></b></small>

## first impression

`Cargo` is a build system that I don't think much about. Tooling is amazing: `rust-analyzer`, `clippy`, `fmt` (`Rust` is the only language where a formatter doesn't annoy me), plus community tools like `cargo-asm` and lots of others.

---

And `Rust` has a lot of nice features!

* Enums
* backtraces
* built-in checks (out-of-bounds, alignment, overflows / zero-div). I whish they were more optional though
* No constructors (seriously, there are more constructors in `C++` than there are math subjects). <span><video autoplay muted loop playsinline width="60%">
    <source src="/media/cpp_constructors_meme.webm" type="video/webm" />
    </video>
    </span>
* Fast std containers
* built-in tests & benchmarks (`#![feature(test)]` + `black_box` makes it soooo easy).
* Stack slices
* `include_bytes!()` (i wish it was auto-aligned)
* Simple web builds (though you do need `--target-cpu=mvp` now).
<details>
    <summary>
        Click to see my renderer running in web! (right here)
    </summary>

    <div class="lum-canvas-container">
        <canvas class="lum-canvas" id="lum_canvas"></canvas>
    </div>

    <script type="module">
        // generated by wasm-bindgen, runs my Rust code (Lum demo)
        import init from '/../pkg/demo_lib.js';
        async function start_lum() {
            try {
                await init('/../pkg/demo_lib_bg.wasm');
            } catch (e) {
                console.error("Failed to init WASM:", e);
            }
        }
        start_lum();
    </script>
</details>

## diving deeper

I tried to remember my learning experience. Here is some of it (i guess i should start taking notes, lol)

* I feel like shared mutability is underexplained (ofcourse, there is surely enough information and good examples... somewhere)
* Sometimes, there is no idiomatic approach - builder patterns vs just structs vs functions, Into<_> vs specialized functions
* I dont feel like compiler errors are THAT much better than C++ ones apart from trivial cases (which Rust handles separately). Who cares about println()?
* I still have no idea if it clicked or not. Am i completely misunderstaning the great idea? Who knows
* Sometimes i just dont know if im right and cant find any examples. I thought that it clicked and i tried to utilize move semantics only to get to a point of mistmatch between drop (which takes &mut and not mut) and the fact that i need to take out a thing from a struct. I had to either wrap it in option (so, more idiomatic refactor leads to worse perfomance), or use uninit

I love that Rust is the first langauge where i have seen some "finished" libraries, that are not maintained simply because they dont need it

## blazingly fastâ€¦ sometimes

**Performance-wise, `Rust` is truly a rocket. But not all `Rust`.**

`C`-like* `Rust` is a beast. Sticking to references and simple struct hierarchy forces you into code that produces insane assembly. However, wrap everything in `Option`s, `Rc`s and `Box`es, `dyn trait`s and deep nested containers, and it's not so fast anymore.

So far, most `Rust` code I've seen sticks to one of those two extremes - and people dont feel like telling you right away which one it is for a specific library. And there's also a trend to trick the borrow checker - `Rc`s and `Vec[index]` as "virtual memory". Is it just me, or do a lot of people praise the borrow checker but then subvert it? <i class="note"> * - a question: am I missing something or is there no way to make math more C-like? I mean something like this but compiler-driven: <a href="https://github.com/platonvin/unsafe_math">https://github.com/platonvin/unsafe_math </a> </i>

## some real info

* my binary sizes went from ~600 KB to ~700 KB - likely due to stack slices (which is good: why heap-allocate if the stack suffices?).
* performance-wise nothing really changed: `Rust` is faster at low opt-levels (precompiled std?), and on highest opt-levels the gap narrows.
* compile times actually improved, though both `C++` and `Rust` compile times still hurt iteration speed.

## libraries: the weak link

This is kind of a point of failure for me in the `Rust` ecosystem - there just aren't that many great libraries. Initializing OpenGL with winit (whose examples use deprecated code cause they change API every second) and glow is harder than with assembly. Algebra libraries are written by people who dont seem to code at all. Peak frustration was when I couldn't figure out the MagicaVoxel (.vox) parser docs and ended up porting the `C++` parser instead (spent less time on that, huh).

In `Rust` you don't spend a day trying to make a library compile - you spend a day looking for one that doesn't suck. Crates refactor every few months and break APIs for no practical reason. Documentation is often useless (says a lot, explains nothing), and reading source is unreasonably hard because logic is smeared acros dozen layers of tiny functions (std has better docs (i still dont understand cells, pin and leak()) but sufffers from unreadable source more. Maybe its just experience, but i feel relatively comfortable reading sources of C/C++ libraries). And a lot of libraries pull a lot of semi-unnecessary dependencies (not behind a feature). Its common to have 200 crates to compile for a very simple CLI

## whats next?

overall, I'm going to use `Rust` for a while. I don't any other language* offering significant improvements that'd make me switch (but who knows).

I'd like "safe" to be more optional, nicer syntax for "unsafe", first-class SIMD, much faster compile times, and more importantly - simplicity as a language idea, whith library authors aware of it.

I will probably depend less on external crates in future for simplicity and perfomance (btw, just removing thiserror and anyhow cut ~100kb)