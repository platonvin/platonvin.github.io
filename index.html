<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>platonvin</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            color: #e3f6f5;
            display: flex;
            align-items: center;
            justify-content: center;
            scrollbar-color: rgb(26, 26, 26) rgb(53, 53, 53);
        }
        #clickBackground {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            color: rgba(0, 0, 0, 0);
        }
        #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        #content {
            position: absolute;
            top: 10px;
            left: 15px;
            /* right: 15px; */
            z-index: 1;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: inline-block;
            max-width: 90%;
            border-radius: 10px;
            scrollbar-color: rgb(223, 223, 223) gray;
        }
        h1 {
            font-size: 2.5em;
            margin: 0 0 20px;
        }
        p {
            font-size: 1.2em;
            margin: 10px 0;
        }
        a {
            color: #51b0b8;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
            color: #9751b8;
        }
                /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            /* background-color: rgba(0, 0, 0, 0.4); */
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .modal-content {
            /* background-color: #fefefe; */
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 10px;
        }
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        /* CV content styles */
        #cv-content {
            display: none;
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            /* bottom: 20px; */
            overflow-y: scroll; height:800px;
            z-index: 1;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            overflow-y: auto;
            max-width: 90%;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <div id="clickBackground">
    </div>
    <div id="content">
        <h1>Hi there!</h1>
        <p>If you dont see any fractals or they are weirdly colored - try disabling all extensions and using desktop device =^◕⩊◕^=</p>
        <p>I'm a graphics/gamedev developer with a preference for C-family languages, and I'm also a voxel engines fan.</p>
        <p>If you have any good-looking ideas for a voxel game engine, you can message me for help.</p>
        <p>Currently, I'm working on a voxel path tracing engine called "Lum".</p>
        <p>You can reach me at <a href="https://t.me/platonvin" target="_blank">t.me/platonvin</a> or <a href="mailto:platonvin@gmail.com">platonvin@gmail.com</a>.</p>
        <p>This site only exists to showcase my Julia set renderer =^◕⩊◕^=</p>
        <h1><a href="javascript:void(0);" onclick="openModal()">Hire me</a></h1>
    </div>
    <div id="cv-content">
        <span class="close" onclick="closeCv()">&times;</span>
        <h2 id="professional-summary">Professional Summary</h2>
        <p>Graphics and game development programmer with ~3 years of experience focusing on low-level game engine programming. Background in physics competitions</p>
        <hr>
        <h2 id="programming-experience">Programming Experience</h2>
        <h3 id="lum-game-engine"><em>Lum</em> Game Engine</h3>
        <h6 id="mostly-vulkan-renderer">(mostly Vulkan renderer)</h6>
        <ul>
        <li>
        <p><strong>Sparse voxel block grid real-time path tracer</strong> (part of <em><strong>Lum</strong></em> engine)
        Implemented without VK_KHR_ray_tracing_pipeline, using only compute shaders</p>
        </li>
        <li>
        <p><strong>Spatiotemporal A-trous real-time filter</strong> (part of <em><strong>Lum</strong></em> engine)
        Developed a denoiser and accumulator (through motion vectors)</p>
        </li>
        <li>
        <p><strong>Profile-guided upscaler</strong> (part of <em><strong>Lum</strong></em> engine)
        Created an upscaler that performs better than FSR (for voxels)</p>
        </li>
        <li>
        <p><strong>Distance field Builder and path tracer</strong> (initially part of <em><strong>Lum</strong></em> engine)
        Created linear time sdf builder and pretty efficient sdf marcher</p>
        </li>
        </ul>
        <h4 id="assembler-language">Assembler language</h4>
        <ul>
        <li>Designed and implemented CPU emulator with custom ASM language - compiler and interpreter</li>
        </ul>
        <h4 id="webgl2-fractal-raymarcher">WebGl2 fractal raymarcher</h4>
        <ul>
        <li>Implemented Julia set (&quot;3D fractal bulb&quot;) renderer developed as the background for my portfolio <a href="https://platonvin.github.io">site</a> on GitHub</li>
        </ul>
        <h4 id="opengl-path-tracer-truemmo">OpenGL path tracer (<em>true_mmo</em>)</h4>
        <ul>
        <li>Developed a path tracer in OpenGL (for textured-blocks-only) with simple physics engine (convex shape intersection + Newton laws of motion) and server side (<em>true_mmo-server</em>)</li>
        </ul>
        <h5 id="minor-experience">minor experience:</h5>
        <ul>
        <li>Libraries ranging from a &quot;safe stack&quot; to a macro's monster for GLSL-style linear algebra in pure C</li>
        </ul>
        <hr>
        <h3 id="education">Education</h3>
        <h4 id="incomplete-degree-in-applied-mathematics-and-physic">Incomplete Degree in applied mathematics and physic</h4>
        <p><strong>Moscow Institute of Physics and Technology (MIPT)</strong></p>
        <hr>
        <h2 id="skills">Skills</h2>
        <ul>
        <li>
        <h3 id="primary">Primary</h3>
        <ul>
        <li><strong>C &amp; C++ core</strong></li>
        <li><strong>C &amp; C++ Build systems &amp; toolchains</strong></li>
        <li><strong>ASM and hardware relationships with languages</strong></li>
        <li><strong>Vulkan</strong></li>
        <li><strong>OpenGL/WebGL</strong></li>
        <li><strong>ray-tracing</strong>
        <ul>
        <li>physically correct rendering</li>
        <li>brdf</li>
        </ul>
        </li>
        <li><strong>in-depth Physics knowledge</strong></li>
        </ul>
        </li>
        <li>
        <h3 id="secondary">Secondary</h3>
        <ul>
        <li>
        <p><strong>GLSL</strong></p>
        <ul>
        <li>subgroup operations</li>
        </ul>
        </li>
        <li>
        <p><strong>shader effects</strong></p>
        <ul>
        <li>color mapping, noise, dithering, bloom and others</li>
        </ul>
        </li>
        <li>
        <p><strong>Python</strong></p>
        <ul>
        <li>network data scrapping and analytics, &quot;everyday&quot; scripts</li>
        </ul>
        </li>
        <li>
        <p><strong>C/C++ Code Generation (Macros)</strong></p>
        <ul>
        <li>C macro system</li>
        </ul>
        </li>
        <li>
        <p><strong>Networking</strong></p>
        <ul>
        <li>KCP / TCP / UDP</li>
        </ul>
        </li>
        <li>
        <p><strong>Git</strong></p>
        </li>
        <li>
        <p><strong>CSS/HTML</strong></p>
        <ul>
        <li>also RmlUi (Qt but faster) markup &amp; styling languages, they are pretty similar</li>
        </ul>
        </li>
        </ul>
        </li>
        </ul>
    </div>
        <div id="hireMeModal" class="modal">
            <div class="modal-content">
                <span class="close" onclick="closeModal()">&times;</span>
                <h2>Hire Me</h2>
                <p><a href="javascript:void(0);" onclick="toggleCV()">View my CV</a></p>
                <p><a href="https://platonvin.github.io/cv.pdf" target="_blank">Download my CV (pdf)</a></p>
            </div>
        </div>
        <script>
            var modal = document.getElementById("hireMeModal");
            var cvContent = document.getElementById("cv-content");
            var mainContent = document.getElementById("content");
            var backgroundContent = document.getElementById("clickBackground");

            function  getStateModal() {return     (modal.style.display === "block")}
            function  getStateCv()    {return (cvContent.style.display === "block")}
            
            function  openModal() {modal.style.display = "block";}
            function closeModal() {modal.style.display = "none";}
            var _blur;

            window.mobileAndTabletCheck = function() {
                let check = false;
                (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
                return check;
            };

            if(window.mobileAndTabletCheck()){
                _blur = 'blur(3px)';
                mainContent.style.backdropFilter = 'blur(4px)';
                mainContent.style.background = "#00000040";
                mainContent.style.left = "5px";
                mainContent.style.right = "5px";
                mainContent.style.top = "5px";
                // mainContent.style.padding = "8px";
                mainContent.style.paddingLeft = "12px";
                mainContent.style.paddingTop = "12px";
                // mainContent.style.paddingRight = "12px";
            } else {
                _blur = 'blur(10px)';
            }
            
            function  openCv() {
                cvContent.style.display = "block";
                mainContent.style.filter = _blur;
            }
            function closeCv() {
                cvContent.style.display = "none";
                mainContent.style.filter = 'blur(0px)';
            }
            
            function toggleCV() {
                if (getStateModal()) {
                    closeModal();
                }
                if(getStateCv()){
                    closeCv();
                } else {
                    openCv();
                }
            }
            window.onclick = function(event) {
                if (event.target === modal) {
                    closeModal();
                } 
            }
            document.addEventListener("keydown", function(event) {
                if (event.key === "Escape") {
                    if (getStateModal()) {
                        closeModal();
                    }
                    if (getStateCv()) {
                        closeCv();
                    }
                }
            });
            </script>
        <!-- does have to be #included? -->
        <script>
            window.mobileAndTabletCheck = function() {
                let check = false;
                (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
                return check;
            };

            function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

function initWebGL() {
    const canvas = document.getElementById('backgroundCanvas');
    const gl = canvas.getContext('webgl2');

    if (!gl) {
        console.error('WebGL not supported');
        return;
    }

    // Vertex shader source code
    const vertexShaderSource = 
/*glsl*/`#version 300 es
#pragma vscode_glsllint_stage: vert

precision highp float;

uniform vec2 u_resolution;

layout(location = 0) in vec4 a_position;

out vec3 ray_pos;
out vec3 ray_dir;


void main() {
    vec2 pix_pos = a_position.xy;
    // pix_pos -= 0.5;
    // pix_pos *= 2.0;

    vec2 scaled_pix_pos = pix_pos * u_resolution.xy / 1000.0;

    vec3 camera_dir = normalize(vec3(-1,-1,-0.5));
    vec3 camera_pos = vec3(1.1,1.1,0.5);
        // camera_pos -= camera_dir*2.0;
    //  camera_pos.x += 0.25 * sin(u_time/2.12);
    //  camera_pos.y += 0.25 * sin(u_time/4.12);
    //  camera_pos.z += 0.25 * sin(u_time/2.12);
    //  camera_pos.z += 0.25 * sin(u_time/2.12);
    vec3 horizline = normalize(vec3(1,-1,0));

    vec3 vertiline = normalize(cross(camera_dir, horizline));

    ray_pos = camera_pos + horizline*scaled_pix_pos.x*0.6 + vertiline*scaled_pix_pos.y*0.6;
    // vec3 ray_dir = normalize(camera_dir + horizline*scaled_pix_pos.x*0.1 + vertiline*scaled_pix_pos.y*0.1);
    ray_dir = camera_dir;
    
    gl_Position = a_position;
    // clip_pos = a_position;
}
    `;

    // Fragment shader source code
    const fragmentShaderSource = 
/*glsl*/`#version 300 es
#pragma vscode_glsllint_stage: frag

precision highp float;

uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_scroll;

uniform int u_iterations;
uniform float u_epsilon;

//calculated on cpu
uniform vec4 u_C;
//calculated on cpu
uniform float u_SwizzleMix;

//calculated in vertex shader
in vec3 ray_pos;
in vec3 ray_dir;

layout(location = 0) out vec4 fragColor;

//actually just sphere
// float estimate_distance_sphere(const vec3 ray_pos){
//     float dist;
//     dist = abs(length(vec3(3.1) - ray_pos)) - 0.9;
//     return dist;
// }
vec4 quat_mul(in vec4 q1, in vec4 q2){
    vec4 r;
    r.x = q1.x*q2.x - dot( q1.yzw, q2.yzw );
    r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross( q1.yzw, q2.yzw );
    return r;
}
vec4 quat_square(vec4 q){
    vec4 r;
    r.x = q.x*q.x - dot( q.yzw, q.yzw );
    r.yzw = 2.0*q.x*q.yzw;
    return r;
}
float quat_length_squared(in vec4 q){
    return dot(q,q);
}
vec4 quat_cube(in vec4 q){
    vec4 q2 = q*q;
    return vec4(q.x * (q2.x - 3.0*q2.y - 3.0*q2.z - 3.0*q2.w), 
    q.yzw * (3.0*q2.x - q2.y - q2.z - q2.w));
}

const float ESCAPE_THRESHOLD = 42.0;
const int MAX_ITERATIONS_DF = 10; //actually, very few steps needed
int MAX_ITERATIONS_MARCH;
float epsilon;
// const int MAX_ITERATIONS_MARCH = 65;
// const float epsilon = 1e-3;

float get_sdf(in vec3 pos, in vec4 C){
    vec4 z = vec4(pos, 0.0);
    float dz2 = 1.0;
	float m2  = 0.0;
    float orbit   = 1e10;
    
    for(int i=0; i < MAX_ITERATIONS_DF; i++) {
        //for ^3
		dz2 *= 9.0*quat_length_squared(quat_square(z));
		z = quat_cube( z ) + C;

        //for ^2
		// dz2 *= 4.0*quat_length_squared(z);
		// z = quat_square( z ) + C;
        
        m2 = quat_length_squared(z);

        // "orbit trapping"
        // point, plane or 3d space. Plane (two values) just looks better
        vec2 swizzle = mix(z.xy, z.wz, u_SwizzleMix); //mixing this just for fun
            //  swizzle = mix(swizzle, z.yw, sin(u_time / 5.663)); //mixing this just for fun
            // swizzle = z.xy;
        vec2 point = (vec2(+0.5,-0.3));
        orbit = min(orbit, (length(swizzle - point)-0.2)); //arbitrary swizzling, point and difference 
        
        if(m2 > ESCAPE_THRESHOLD) break;				 
	}
	float d = log2(m2)*sqrt(m2/dz2) / 4.0; // / 4.0 cause its lower bound

    d = min(orbit,d);
    // d = max(d, p.z); //to cut in half TODO use angle

	return float(d);        
}

struct marching_res {
    float dist;
    float iter;
};

vec2 zero_sphere_dist(in vec3 pos, in vec3 dir, in float radius, out bool intersects){
	float b = dot(pos, dir);
	float c = dot(pos, pos) - radius*radius;
	float h = b*b - c;
	if(h < 0.0) {
        intersects = false;
        return vec2(0);
    }
    h = sqrt(h);
    intersects = true;
    return vec2(-b-h, -b+h);
}
marching_res intersect_julia(inout vec3 ray_origin, in vec3 ray_direction, in vec4 C, in float epsilon){
    float bounding_radius = 1.2;

    //teleport to bounding sphere to save time
    // float sd = zero_sphere_dist(ray_origin, ray_direction, bounding_radius);
    // ray_origin = ray_origin + sd*ray_direction;

    // float dist = 0.0;
    // int iter;
    // for (iter=0; iter<MAX_ITERATIONS_MARCH; iter++){
    //     dist = get_sdf(ray_origin, C);
    //     ray_origin += dist*ray_direction;

    //     if((dist < epsilon) 
    //         || (dot(ray_origin, ray_origin) > bounding_radius*bounding_radius*1.0)
    //     ) {
    //         break;
    //     }
    // }

    float T = 0.0;
    // teleport to bounding sphere to save time
    bool intersects = false;
    vec2 bounding_T = zero_sphere_dist(ray_origin, ray_direction, bounding_radius, intersects);
    if(!intersects) {
        marching_res res;
        res.dist = 1e10;
        res.iter = float(0);
        return res;
    }

    T = bounding_T.x;

    float dist = 0.0;
    int iter;
    for (iter=0; iter<MAX_ITERATIONS_MARCH; iter++){
        dist = get_sdf(ray_origin + T*ray_direction, C);
        T += dist;

        if((dist < epsilon) 
            || ((T) > bounding_T.y)
        ) {
            break;
        }
    }

    ray_origin = ray_origin + T*ray_direction;
    
    marching_res res;

    res.dist = dist;
    res.iter = float(iter);
    
    return res;
}
vec3 estimate_normals(in vec3 pos, in vec4 C, in float epsilon){
    vec2 e = vec2(1.0,-1.0)*0.5773*epsilon;
    return normalize(e.xyy*get_sdf(pos + e.xyy, C)+ 
					 e.yyx*get_sdf(pos + e.yyx, C)+ 
					 e.yxy*get_sdf(pos + e.yxy, C)+ 
					 e.xxx*get_sdf(pos + e.xxx, C));
}

//why df fine does not work (even with hint)?
// vec3 estimate_normals_local_diff(vec3 position){
//     vec3 p = position * 10.0;
//     vec3 X = dFdx(p);
//     vec3 Y = dFdy(p);
//     return normalize(cross(X,Y));
// }
float luminance(in vec3 color){
    vec3 luminance_const = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, luminance_const);
}
vec3 rgb2hsv(in vec3 c){
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
vec3 hsv2rgb(in vec3 c){
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
vec3 hex2rgb (in int u_color){
    int r = (u_color / 256 / 256) % 256;
    int g = (u_color / 256      ) % 256;
    int b = (u_color            ) % 256;

    return vec3(r,g,b) / 256.0;
}

//why ## does not work?
// #define extrude_color_from_hex(c1,c2,c3,c4,c5)
// palette[0] = hex2rgb(0x ## c1);
// palette[1] = hex2rgb(0x ## c2);
// palette[2] = hex2rgb(0x ## c3);
// palette[3] = hex2rgb(0x ## c4);
// palette[4] = hex2rgb(0x ## c5);

//WHER IS MY __VA_ARGS__
// #define interpolator(color_count, ...)

vec3 interpolate_palette(in float x){
    const int color_count = 8; 
    
    vec3 palette[color_count];
         palette[0] = hex2rgb(0x2b3634);
         palette[1] = hex2rgb(0x474848);
         palette[2] = hex2rgb(0x6e5f52);
         palette[3] = hex2rgb(0xa2856c);
         palette[4] = hex2rgb(0xa0a294);
         palette[5] = hex2rgb(0xdcb9a0);
         palette[6] = hex2rgb(0xf3dbc6);
         palette[7] = hex2rgb(0xfffefe);
        //  palette[8] = hex2rgb(0xb199a3);
        //  palette[9] = hex2rgb(0xd5a3a7);
        //  palette[10] = hex2rgb(0xf8adac);
        //  palette[11] = hex2rgb(0xffbdbb);

    vec3 color = vec3(0);

    float section_count = float(color_count-1);
    float scaled_x = clamp(x,0.0,1.0)*section_count;

    int section = int(ceil(scaled_x));
    float fraction = fract(scaled_x);

    if(section == (color_count-1)) {
        section -= 1;
        fraction = 1.0;
    }
    
    vec3 color1 = palette[section];
    vec3 color2 = palette[section+1];
    color = mix(color1, color2, fraction);
    
    return color; 
}
vec3 color_surface(in vec3 pos, in vec3 nor, in float iter){
    vec3 rgb_color;
    
    //assigning color to iterations
    rgb_color = interpolate_palette(0.5+sin(iter/5.0)*0.5) / 1.5;
    
    //lighting
    float lighting = 0.15; // ambient     
    lighting += (-dot(nor, normalize(vec3(-1,-1,+1))))*0.6; //directional sun                

    
    vec3 plight_pos = vec3(1.3*sin(u_time), 1.3*cos(u_time), 0);
    vec3 plight_dir = pos - plight_pos;
    lighting += (-dot(nor, plight_dir))*0.1; //point light
    
    float plight_depth = dot(plight_pos, ray_dir);
    float    set_depth = dot(       pos, ray_dir);

    
    //draw light source itself
    // if((plight_depth < set_depth) && (pligh))

    rgb_color *= lighting;
    // u_time;
    
    return rgb_color;
}
//how close is already point of set
void main() {
    MAX_ITERATIONS_MARCH =  u_iterations;
    epsilon = u_epsilon;

    vec3 pos = ray_pos;
    vec3 dir = ray_dir;

    vec4 C = u_C;

    marching_res marching_res = intersect_julia(pos, dir, C, epsilon);
    float distance_to_set = marching_res.dist;

    vec3 color = vec3(0.2);
    if(distance_to_set <= epsilon) {
        //lowered to make mobile happy
        vec3 normal = estimate_normals(pos, C, 0.0005);
        // vec3 normal = estimate_normals(pos, C, 0.001);
        // color = normal;
        color = color_surface(pos, normal, (marching_res.iter));
    }
    fragColor = vec4(clamp(color,0.0,1.0), 1.0);
}
    `;

    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        return;
    }

    gl.useProgram(program);

    //fullscreen triangle
    const vertices = new Float32Array([
        -1, 1,
        3, 1,
        -1, -3
    ]);

    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const positionLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(positionLocation);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

    const timeUniform = gl.getUniformLocation(program, 'u_time');
    const resolutionUniform = gl.getUniformLocation(program, 'u_resolution');
    const iterationsUniform = gl.getUniformLocation(program, 'u_iterations');
    const epsilonUniform = gl.getUniformLocation(program, 'u_epsilon');
    const mouseUniform = gl.getUniformLocation(program, 'u_mouse');
    const scrollUniform = gl.getUniformLocation(program, 'u_scroll');
    const ConstantUniform = gl.getUniformLocation(program, 'u_C');
    const swizzleMixUniform = gl.getUniformLocation(program, 'u_SwizzleMix');

    gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
    
    //do nat change at all
    if(window.mobileAndTabletCheck()){
            //if mobile, rescale for better experience
            // gl.uniform2f(resolutionUniform, canvas.width*3.0, canvas.height*1.5);
            gl.uniform1f(epsilonUniform, 4e-3);
            gl.uniform1i(iterationsUniform, 37);
    } else {
            // gl.uniform2f(resolutionUniform, canvas.width, canvas.height);
            // const int MAX_ITERATIONS_MARCH = 65;
            // const float epsilon = 1e-3;
            gl.uniform1f(epsilonUniform, 1e-3);
            gl.uniform1i(iterationsUniform, 65);
    }

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    let startTime = Date.now();
    let mouseX = 0, mouseY = 0;
    let scrollY = 0;

    window.addEventListener('mousemove', (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
    });

    window.addEventListener('scroll', (e) => {
        scrollY = window.scrollY;
    });

    function render() {
        //10.0 to prevent 0-time boring trigonometry
        const currentTime = 10.0 + (Date.now() - startTime) / 1000;

        if(window.mobileAndTabletCheck()){
            //if mobile, rescale for better experience
            gl.uniform2f(resolutionUniform, canvas.width*3.0, canvas.height*1.5);
            // gl.uniform1f(epsilonUniform, 5e-3);
            // gl.uniform1i(iterationsUniform, 35);
        } else {
            gl.uniform2f(resolutionUniform, canvas.width, canvas.height);
            // const int MAX_ITERATIONS_MARCH = 65;
            // const float epsilon = 1e-3;
            // gl.uniform1f(epsilonUniform, 1e-3);
            // gl.uniform1i(iterationsUniform, 65);
        }

        //no need to clear
        // gl.clear(gl.COLOR_BUFFER_BIT);

        gl.uniform1f(timeUniform, currentTime);

        
        //per-dispatch instead of per-invocatopn
        C_x = -0.65 + -0.65*0.15 * Math.sin((currentTime + 23.0)/2.12);
        C_y = -0.3  + -0.3 *0.15 * Math.sin((currentTime + 23.0)/3.523);
        C_z = +0.6  + +0.6 *0.15 * Math.sin((currentTime + 23.0)/5.634);
        C_w = -0.2  + -0.2 *0.15 * Math.sin((currentTime + 23.0)/7.6345);
        
        gl.uniform1f(swizzleMixUniform, Math.sin((currentTime / 3.312)));

        gl.uniform4f(ConstantUniform, C_x, C_y, C_z, C_w);

        gl.uniform2f(mouseUniform, mouseX, canvas.height - mouseY);
        gl.uniform1f(scrollUniform, scrollY);

        gl.drawArrays(gl.TRIANGLES, 0, 3);

        requestAnimationFrame(render);
    }

    render();
}

initWebGL();
        </script>
    </body>
</html>